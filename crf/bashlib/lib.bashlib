#!/bin/bash
#############################################################################
#
#   lib.bashlib: container_build_framework
#
#  thanks to Stephen R. Scaffidi for relativize
#        (https://gist.github.com/hercynium/3899407#file-relpath-bash)
#
#############################################################################

function lib.copyFileToRuntime()
{
    local -r loc="${1^^:?'Input parameter "loc" must be defined'}"
    local -r file="${2:?'Input parameter "file" must be defined'}"
    case "$loc" in
        BIN)         : ;;
        ENV)         : ;; 
        LIB)         : ;;
        STARTUP)     : ;;
        *)  $LOG "Invalid runtime location '$loc' specified${LF}" 'error'
            exit 1;;
    esac
    
    local -r rtFile="$( "crf.$loc" )/$( basename "$file" )"
    if [ -e "$rtFile" ]; then
        $LOG "Attempt to overwrite file '$rtFile' will likely result in unintentend consequences${LF}" 'error'
        exit 1
    fi
    
    # use input file if it exists, otherwise determine if file exists in coresponding '/usr/local/crf' folder
    local srcFile="$file"
    [ -e "$srcFile" ] || srcFile="$( cbf.BASE )/usr/local/crf/$( basename "$( "crf.$loc" )" )/$( basename "$file" )"
    if [ -e "$srcFile" ]; then
        echo "copying $srcFile to $rtFile"
        # copy file
        cp "$srcFile" "$rtFile"
    else
        $LOG "Attempt to copy non-existent file '$srcFile' to ${rtFile}${LF}" 'warning'
    fi
}
export -f lib.copyFileToRuntime

#############################################################################
#
# usage: lib.file_env VAR [DEFAULT]
#    ie: lib.file_env 'XYZ_DB_PASSWORD' 'example'
# (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of
#  "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature) 
#
function lib.file_env()
{
    local -r var="${1:?'Input parameter "var" must be defined'}"
    local def="${2:-}"

    local fileVar="${var}_FILE"
    if [ "${!var:-}" ] && [ "${!fileVar:-}" ]; then
        echo >&2 "error: both $var and $fileVar are set (but are exclusive)"
        exit 1
    fi
    local val="$def"
    if [ "${!var:-}" ]; then
        val="${!var}"
    elif [ "${!fileVar:-}" ]; then
        val="$(< "${!fileVar}")"
    fi
    export "$var"="$val"
    unset "$fileVar"
}
export -f lib.file_env

#############################################################################
function lib.getFiles()
{
    local -r dir=${1:?'Input parameter "dir" must be defined'}
    local OIFS=$IFS
    
    IFS=$'\r\n'
    [ ! -d "$dir" ] || find "$dir"  -maxdepth 1 -and ! -name '.*' -and  -type f -or -type l | sort
    IFS=$OIFS
}
export -f lib.getFiles

#############################################################################
function lib.getProperty()
{
    local -r prop=${1:?'Input parameter "prop" must be defined'}
    local -r file=${2:?'Input parameter "file" must be defined'}
    
    grep -e "$prop" "$file" | sed -e "s/${prop}//"
}
export -f lib.getProperty

#############################################################################
function lib.indirectReference()
{
    local -r ahash=${1:?'Input parameter "ahash" must be defined'}
    local -r key=${2:?'Input parameter "key" must be defined'}
    local SAVED_OPTIONS=$(set +o)
    set +o nounset
    local -r default="$3"

    local val=$( eval "echo \${$ahash[$key]}" )
    [ -n "$val" ] || val="$default"
    echo "$val"
    eval "$SAVED_OPTIONS"
}
export -f lib.indirectReference

#############################################################################
function lib.intersect()
{
    local -r a1=${1:?'Input parameter "a1" must be defined'}
    local -r a2=${2:?'Input parameter "a2" must be defined'}

    # find entries of a1 which are in a2
    local -a common=()
    for item in $a1; do
        for ref in $a2; do
            if [ "$item" = "$ref" ]; then
                common+=( "$item" )
                break
            fi
        done
    done
    [ ${#common[*]} -eq 0 ] || echo "${common[*]}"
}
export -f lib.intersect

#############################################################################
function lib.lookupId()
{
    local -r database=${1:?'Input parameter "database" must be defined'}
    local -r entry=${2:?'Input parameter "entry" must be defined'}
    local -r default=${3:?'Input parameter "default" must be defined'}

    local id=$(getent "$database" "$entry" | cut -d: -f3)
    [ "$id" ] || id=$default
    echo "$id"
}
export -f lib.lookupId

#############################################################################
function lib.OSid()
{
    if [ -e /etc/os-release ]; then
        grep -e '^ID=' /etc/os-release | awk -F'=' '{ print $2 }'
    else
        echo 'windows'
    fi
}
export -f lib.OSid

#############################################################################
function lib.primaryPid
{
    local -r cmdName=${1:?'Input parameter "cmdName" must be defined'}

    ps -o pid,ppid,comm | \
    grep "$cmdName" | \
    grep -v 'grep' | \
    awk '{ pids[$1]=$2 } END { for (pid in pids) { id = pids[pid]; if (! pids[id]) { print pid } } }'
}
export -f lib.primaryPid

#############################################################################
function lib.readFile()
{
    local -r file=${1:?'Input parameter "file" must be defined'}
    
    if [ -e "$file" ]; then
        cat "$file"
    else
        echo "File: '$file' does not exist"
    fi
}
export -f lib.readFile

######################################################################
function lib.relativize()
{
    local from="${1:?'Input parameter "from" must be defined'}"
    local to="${2:?'Input parameter "to" must be defined'}"
    local OIFS=$IFS

    from="${from//\/\//\/}"
    from="${from%/}"
    IFS=/
    dirs=("${from#/}")
    for to; do
        to="${to//\/\//\/}"
        to="${to%/}"
        local commonPrefix=/
        for d in "${dirs[@]}"; do
            case "$to/" in "$commonPrefix$d/"*) ;;
                *) break;;
            esac
            commonPrefix+="$d/"
        done
        local ancestor="${from#${commonPrefix%/}}"
        ancestor="${ancestor//[^\/]/}"
        ancestor="${ancestor//\//..\/}"
    done
    IFS=$OIFS
    echo -n "$ancestor${to#$commonPrefix}"
}
export -f lib.relativize

#############################################################################
function lib.updateConfigFile()
{
    local -r param="${1:?'Input parameter "param" must be defined'}"
    local -r attr="${2:?'Input parameter "attr" must be defined'}"
    local -r config_file="${3:?'Input parameter "config_file" must be defined'}"

    if [[ "$param" ]]; then
        if grep -q "$attr" "config_file" ; then
            sed -i "s|^$attr=.*$|$attr=$param|" "$config_file" 
        else
            echo "$attr=$param" >> "$config_file"
        fi
    fi
}
export -f lib.updateConfigFile

#############################################################################
function lib.updateRuntimeEnvironment()
{
    local -a in_array="${1:?'Input parameter "in_array" must be defined'}"
    local -r envFile="$( crf.BIN )/rt.environment"
    local -r prefix='declare -x'

    for line in ${in_array[@]} ; do
        local var="${line%%=*}"
        if grep -q "^${prefix} ${var}=" "$envFile" ; then
            sed -i "s|^${prefix} ${var}=.*$|${prefix} $line|" "$envFile" 
        else
            echo "${prefix} $line" >> "$envFile"
        fi
    done
}
export -f lib.updateRuntimeEnvironment
