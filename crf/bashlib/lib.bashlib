#!/bin/bash
#############################################################################
#
#   lib.bashlib: container_build_framework
#
#############################################################################

function lib.copyFileToRuntimeEnvironment()
{
    local -r file="${1:?'Input parameter "file" must be defined'}"
    local -r envFile="${CRF['env']}/$( basename "$file")"
    
    if [ -e "$envFile" ]; then
        $LOG "Attempt to overwrite file '$envFile' will likely result in unintentend consequences${LF}" 'error'
        exit 1
    fi

    echo "copying $file"
    # copy file
    [ ! -e "$file" ] || cp "$file" "$envFile"
}

#############################################################################
function lib.createFileForRuntimeEnvironment()
{
    local -r file="${1:?'Input parameter "file" must be defined'}"
    local -a vars="${2:?'Input parameter "vars" must be defined'}"
    local -r envFile="${CRF['env']}/$( basename "$file")" 

    if [ -e "$envFile" ]; then
        $LOG "Attempt to overwrite file '$envFile' will likely result in unintentend consequences${LF}" 'error'
        exit 1
    fi

    echo "creating $envFile"
    echo "#!/bin/bash" > "$envFile"
    echo "# this file is generated!!  DO NOT MODIFY" >> "$envFile"
    
    for var in ${vars[@]}; do
        local val="${!var}"
        [ "$val" = "${val%[[:space:]]*}" ] || val="\"$val\""
        printf "export %s=%s\n" "$var" "$val" >> "$envFile"
    done
}

#############################################################################
function lib.copyFileToRuntimeStartup()
{
    local -r file="${1:?'Input parameter "file" must be defined'}"
    local -r startFile="${CRF['startup']}/$( basename "$file")"
    
    if [ -e "$startFile" ]; then
        $LOG "Attempt to overwrite file '$startFile' will likely result in unintentend consequences${LF}" 'error'
        exit 1
    fi

    echo "copying $file"
    # copy file
    [ ! -e "$file" ] || cp "$file" "$startFile"
}

#############################################################################
# usage: lib.file_env VAR [DEFAULT]
#    ie: lib.file_env 'XYZ_DB_PASSWORD' 'example'
# (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of
#  "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature) 
function lib.file_env()
{
    local -r var="${1:?'Input parameter "var" must be defined'}"
    local def="${2:-}"

    local fileVar="${var}_FILE"
    if [ "${!var:-}" ] && [ "${!fileVar:-}" ]; then
        echo >&2 "error: both $var and $fileVar are set (but are exclusive)"
        exit 1
    fi
    local val="$def"
    if [ "${!var:-}" ]; then
        val="${!var}"
    elif [ "${!fileVar:-}" ]; then
        val="$(< "${!fileVar}")"
    fi
    export "$var"="$val"
    unset "$fileVar"
}

#############################################################################
function lib.getFiles()
{
    local -r dir=${1:?'Input parameter "dir" must be defined'}

    IFS=$'\r\n'
    [ ! -d "$dir" ] || find "$dir"  -maxdepth 1 -and ! -name '.*' -and  -type f -or -type l | sort
}

#############################################################################
function lib.indirectReference()
{
    local -r hash=${1:?'Input parameter "hash" must be defined'}
    local -r key=${2:?'Input parameter "key" must be defined'}
    set +o nounset
    local -r default="$3"

    local val=$( eval "echo \${$hash[$key]}" )
    [ -z "$val" ] && val="$default"
    echo "$val"
    set -o nounset
}

#############################################################################
function lib.readFile()
{
    local -r file=${1:?'Input parameter "file" must be defined'}
    
    if [ -e "$file" ]; then
        cat $file
    else
        echo 'File does not exist'
    fi
}

######################################################################
function lib.relativize()
{
    local from="$1"
    local to="$2"

    from=${from//\/\//\/}
    from=${from%/}
    IFS=/
    dirs=(${from#/})
    for to; do
        to=${to//\/\//\/}
        to=${to%/}
        local commonPrefix=/
        for d in "${dirs[@]}"; do
            case "$to/" in "$commonPrefix$d/"*) ;;
                *) break;;
            esac
            commonPrefix+="$d/"
        done
        local ancestor="${from#${commonPrefix%/}}"
        ancestor=${ancestor//[^\/]/}
        ancestor=${ancestor//\//..\/}
    done
    echo -n "$ancestor${to#$commonPrefix}"
}

#############################################################################
