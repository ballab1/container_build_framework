#!/bin/bash
#############################################################################
#
#   lib.bashlib: container_build_framework
#
#############################################################################

function lib.copyFileToRuntimeEnvironment()
{
    local -r file="${1:?'Input parameter "file" must be defined'}"
    local -r envFile="${CRF['env']}/$( basename "$file")"
    
    if [ -e "$envFile" ]; then
        $LOG "Attempt to overwrite file '$envFile' will likely result in unintentend consequences${LF}" 'error'
        exit 1
    fi

    echo "copying $file"
    # copy file
    [ ! -e "$file" ] || cp "$file" "$envFile"
}

#############################################################################
function lib.copyFileToRuntimeStartup()
{
    local -r file="${1:?'Input parameter "file" must be defined'}"
    local -r startFile="${CRF['startup']}/$( basename "$file")"
    
    if [ -e "$startFile" ]; then
        $LOG "Attempt to overwrite file '$startFile' will likely result in unintentend consequences${LF}" 'error'
        exit 1
    fi

    echo "copying $file"
    # copy file
    [ ! -e "$file" ] || cp "$file" "$startFile"
}

#############################################################################
#
# usage: lib.file_env VAR [DEFAULT]
#    ie: lib.file_env 'XYZ_DB_PASSWORD' 'example'
# (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of
#  "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature) 
#
function lib.file_env()
{
    local -r var="${1:?'Input parameter "var" must be defined'}"
    local def="${2:-}"

    local fileVar="${var}_FILE"
    if [ "${!var:-}" ] && [ "${!fileVar:-}" ]; then
        echo >&2 "error: both $var and $fileVar are set (but are exclusive)"
        exit 1
    fi
    local val="$def"
    if [ "${!var:-}" ]; then
        val="${!var}"
    elif [ "${!fileVar:-}" ]; then
        val="$(< "${!fileVar}")"
    fi
    export "$var"="$val"
    unset "$fileVar"
}

#############################################################################
function lib.getFiles()
{
    local -r dir=${1:?'Input parameter "dir" must be defined'}
    local OIFS=$IFS
    
    IFS=$'\r\n'
    [ ! -d "$dir" ] || find "$dir"  -maxdepth 1 -and ! -name '.*' -and  -type f -or -type l | sort
    IFS=$OIFS
}

#############################################################################
function lib.indirectReference()
{
    local -r ahash=${1:?'Input parameter "ahash" must be defined'}
    local -r key=${2:?'Input parameter "key" must be defined'}
    set +o nounset
    local -r default="$3"

    local val=$( eval "echo \${$ahash[$key]}" )
    [ -n "$val" ] || val="$default"
    echo "$val"
    set -o nounset
}

#############################################################################
function lib.intersect()
{
    local -r a1=${1:?'Input parameter "a1" must be defined'}
    local -r a2=${2:?'Input parameter "a2" must be defined'}

    # find entries of a1 which are in a2
    local -a common=()
    for item in $a1; do
        for ref in $a2; do
            if [ $item = $ref ]; then
                common+=($item)
                break
            fi
        done
    done
    [ ${#common[*]} -eq 0 ] || echo "${common[*]}"
}

#############################################################################
function lib.primaryPid
{
    local -r cmdName=${1:?'Input parameter "cmdName" must be defined'}

    ps -o pid,ppid,comm | \
    grep "$cmdName" | \
    grep -v 'grep' | \
    awk '{ pids[$1]=$2 } END { for (pid in pids) { id = pids[pid]; if (! pids[id]) { print pid } } }'
}

#############################################################################
function lib.readFile()
{
    local -r file=${1:?'Input parameter "file" must be defined'}
    
    if [ -e "$file" ]; then
        cat "$file"
    else
        echo "File: '$file' does not exist"
    fi
}

######################################################################
function lib.relativize()
{
    local from="${1:?'Input parameter "from" must be defined'}"
    local to="${2:?'Input parameter "to" must be defined'}"
    local OIFS=$IFS

    from=${from//\/\//\/}
    from=${from%/}
    IFS=/
    dirs=(${from#/})
    for to; do
        to=${to//\/\//\/}
        to=${to%/}
        local commonPrefix=/
        for d in "${dirs[@]}"; do
            case "$to/" in "$commonPrefix$d/"*) ;;
                *) break;;
            esac
            commonPrefix+="$d/"
        done
        local ancestor="${from#${commonPrefix%/}}"
        ancestor=${ancestor//[^\/]/}
        ancestor=${ancestor//\//..\/}
    done
    IFS=$OIFS
    echo -n "$ancestor${to#$commonPrefix}"
}

#############################################################################
function lib.updateConfigFile()
{
    local -r param="${1:?'Input parameter "param" must be defined'}"
    local -r attr="${2:?'Input parameter "attr" must be defined'}"
    local -r config_file="${3:?'Input parameter "config_file" must be defined'}"

    if [[ "$param" ]]; then
        if grep -q "$attr" "config_file" ; then
            sed -i "s|^$attr=.*$|$attr=$param|" "$config_file" 
        else
            echo "$attr=$param" >> "$config_file"
        fi
    fi
}

#############################################################################
function lib.updateRuntimeEnvironment()
{
    local -a vars="${1:?'Input parameter "vars" must be defined'}"
    
    local -r envFile="${CRF['bin']}/rt.environment"
    for var in ${vars[@]}; do
        local val="${!var}"
        [ "$val" = "${val%[[:space:]]*}" ] || val="\"$val\""
        
        if grep -q "^export ${var}=" "$envFile" ; then
            sed -i "s|^export ${var}=.*$|export $var=\${${var}:-$val}|" "$envFile" 
        else
            printf "export %s=\${${var}:-%s}\n" "$var" "$val" >> "$envFile"
        fi
    done
}

#############################################################################
