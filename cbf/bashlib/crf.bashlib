#!/bin/bash
#############################################################################
#
#   crf.bashlib: container_run_framework
#
#############################################################################

: ${CRF_PROPERTIES_FILE:="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd -P )/CRF.properties"}
export CRF_PROPERTIES_FILE

#############################################################################
function crf.__init()
{
    local -r crf_base="${1:?"Input parameter 'crf' must be passed to 'function ${FUNCNAME[0]}()'"}"
    CRF_PROPERTIES_FILE="${crf_base}/CRF.properties"

    # this function is usually called from bin/init.libraries
    if [ ! -e "$CRF_PROPERTIES_FILE" ]; then
        mkdir -p "$crf_base"
        cat << EOF > "$CRF_PROPERTIES_FILE"
BASE=$crf_base
BIN=${crf_base}/bin
ENV=${crf_base}/environment
LIB=${crf_base}/bashlib
STARTUP=${crf_base}/startup
EOF
        [ "$DEBUG_TRACE" = 0 ] || cat "$CRF_PROPERTIES_FILE"
        [ -e "$(crf.propertiesFile)" ] || term.log "runtime initialized\n"
    fi
#    term.__init
#    trap.__init
}
export -f crf.__init

#############################################################################
function crf.BASE()
{
    lib.getProperty "${FUNCNAME[0]##*.}" "$( crf.propertiesFile )"
}
export -f crf.BASE

#############################################################################
function crf.BIN()
{
    lib.getProperty "${FUNCNAME[0]##*.}" "$( crf.propertiesFile )"
}
export -f crf.BIN

#############################################################################
function crf.ENV()
{
    lib.getProperty "${FUNCNAME[0]##*.}" "$( crf.propertiesFile )"
}
export -f crf.ENV

#############################################################################
function crf.LIB()
{
    lib.getProperty "${FUNCNAME[0]##*.}" "$( crf.propertiesFile )"
}
export -f crf.LIB

#############################################################################
function crf.RT_ENVIRON()
{
    echo "$( crf.BIN )/rt.environment"
}
export -f crf.RT_ENVIRON

#############################################################################
function crf.RT_ENVIRON_PREFIX()
{
    echo 'export '
}
export -f crf.RT_ENVIRON_PREFIX

#############################################################################
function crf.STARTUP()
{
    lib.getProperty "${FUNCNAME[0]##*.}" "$( crf.propertiesFile )"
}
export -f crf.STARTUP

#############################################################################
function crf.alreadyFixed()
{
    local -r dir="${1:?'Input parameter "dir" must be defined'}"
    local -r user=${2:-$(crf.currentUser)}

    [ -z "$user" ] && trap.die "Must specify a user when checking the 'fixUpCache'"

    local cache_file=/tmp/fixUpCache
    touch "$cache_file"

    local -r uid="$(lib.getUID "$user")"
    [ -z "$uid" ] && trap.die "Unable to find specified user '$user' on system, when checking the 'fixUpCache'"
    
    local -r previous="$(lib.getProperty "$dir" "$cache_file")"
    if [ "$previous" ]; then
        if [ "$previous" = "$uid" ]; then
            term.log "    ${dir} already fixed up. Skipping request\n"
        else
            term.log "    ${dir} already fixed up. Skipping request to change to user: $(lib.getUserInfo "$user" 'extended')\n" 'lt_yellow'
        fi
        return 0
    fi
    
    # user not found. Add to cache
    lib.updatePropertyFile "$dir" "$uid" "$cache_file"
    return 1
}
export -f crf.alreadyFixed

#############################################################################
function crf.copyFileToRuntime()
{
    local -r loc="${1^^:?"Input parameter 'loc' must be passed to 'function ${FUNCNAME[0]}()'"}"
    local -r file="${2:?"Input parameter 'file' must be passed to 'function ${FUNCNAME[0]}()'"}"
    local rt_sha

    case "$loc" in
        BIN)         : ;;
        ENV)         : ;;
        LIB)         : ;;
        STARTUP)     : ;;
        *)  trap.die "Invalid runtime location '$loc' specified";;
    esac

    local -r rt_file="$( "crf.$loc" )/$( basename "$file" )"
    [ -e "$rt_file" ] && rt_sha="$(sha256sum "$rt_file" | awk '{ print $1}')"


    # use input file if it exists, otherwise determine if file exists in coresponding '/usr/local/crf' folder
    local src_file="$file"
    [ -e "$src_file" ] || src_file="$( cbf.BASE )/usr/local/crf/$( basename "$( "crf.$loc" )" )/$( basename "$file" )"


    # copy file to crf folder for use by runtime
    if [ -e "$src_file" ]; then
        if [ "${rt_sha:-}" ]; then
            # about to overrite an existing file, just return if it si same as current
            [ "$(sha256sum "$src_file" | awk '{ print $1}')" == "$rt_sha" ] && return
            ( ! cmp -s "$src_file" "$rt_file" ) || continue
            trap.die "Attempt to overwrite file '$rt_file' will likely result in unintented consequences"
        fi

        echo "    copying $src_file to $rt_file"
        # copy file
        cp "$src_file" "$rt_file"
    else
        term.log "Attempt to copy non-existent file '$(basename "$src_file")' to ${rt_file}\n" 'warning'
    fi
}
export -f crf.copyFileToRuntime

#############################################################################
function crf.currentUser()
{
    local user="$(crf.runtimeProperty 'USER')"

    [ "${user:-}" ] && user=$(lib.lookupId "$user" 'passwd')
    [ "${user:-}" ] || [ -z "${USER:-}" ] || user=$(lib.lookupId "$USER" 'passwd')
    [ "${user:-}" ] || [ -z "${UID:-}" ] || user=$(lib.lookupId "$UID" 'passwd')
    [ "${user:-}" ] || user=0

    [ -z "$user" ] && trap.log "No current user identified"

    echo "$user"
}
export -f crf.currentUser

#############################################################################
function crf.fixupDirectory()
{
    local -r dir="${1:?'Input parameter "dir" must be defined'}"
    local -r user=${2:-$(crf.currentUser)}

    [ -z "$user" ] && trap.die "Must specify a user when fixing up a directory"

    if [ ! "$dir" != '/' ]; then
        term.log "Attempt to fix up '${dir}' is not permitted.\n" 'warn'
        return 1
    fi

    # check/update cache of what has been 'fixed up'
    (crf.alreadyFixed "$dir" "$user") && return 0 
    
    # set access on specificed directory
    term.log "    Fixing up directory: ${dir}  for user: $(lib.getUserInfo "$user" 'extended')\n"
    [ -d "$dir" ] || mkdir -p "$dir"
    find "$dir" -type d ! -perm 777 -exec chmod 777 '{}' \; | :
    find "$dir" -type f ! -perm 666 -exec chmod a+rw '{}' \; | :
    
    # set owner to uid & login group for uid
    if [ "$user" != root ] && [ "$user" != 0 ]; then
        (getent passwd $user" > /dev/null 2>&1) || useradd --no-create-home "$user"
        local group="$(lib.getGroupOfUser "$user")"
        (getent group $group" > /dev/null 2>&1) || groupadd "$group"
        find "$dir" ! -user "$user" -exec chown "${user}:$group" '{}' \; | :
    fi
    return 0
}
export -f crf.fixupDirectory

#############################################################################
function crf.logEnvironment()
{
    printf "%s starting.\n" "${CONTAINER_NAME:-}"
    local env_file="$(crf.RT_ENVIRON)"
    [ -e "$env_file" ] || trap.die "No CRF environment definition file: $env_file"
    printf "\nrt.environment:\n"
    for ln in $(cat "$env_file" | sort); do
        [ "${ln:0:6}" = 'export' ] && printf "    %s\n" "$(eval echo ${ln:7})"
    done
    printf "\n"
    printf "    Current user info: %s\n"  "$(getent 'passwd' "$UID")"
    printf "    Target  user info: %s\n\n"  "$(getent 'passwd' "$USER")"
}
export -f crf.logEnvironment

#############################################################################
function crf.prepareEnvironment()
{
    local -a files=( $( lib.getFiles "$( crf.STARTUP )" ) )
    if [ ${#files[*]} -gt 0 ]; then

        # execute scritps in sorted order
        local -a failed_to_run=()
        for _name in $( printf "%s\n" "${files[@]}" | sort ); do
            crf.runScript "$_name" || failed_to_run+=( "$_name" )
        done
        if [ ${#failed_to_run[*]} -gt 0 ]; then
            term.log "Failed to run: ${#failed_to_run[*]} out of ${#files[*]} startup scripts..\n" 'lt_gray'
            [ "$DEBUG_TRACE" = 0 ] || term.log "  files:\n$(printf "    %s\n"  "${files[@]}")\n" 'lt_gray'
#            trap.die "failed to execute all scripts"
        fi
    fi
    chmod a+x "/usr/local/bin/"*

}
export -f crf.prepareEnvironment

#############################################################################
function crf.propertiesFile()
{
    echo "${CRF_PROPERTIES_FILE:="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd -P )/CRF.properties"}"
}
export -f crf.propertiesFile

#############################################################################
function crf.removeFromRuntimeEnvironment()
{
    local -r key="${1:?"Input parameter 'entry' must be passed to 'function ${FUNCNAME[0]}()'"}"
    local -r env_file="$( crf.RT_ENVIRON )"

    if [ -e "$env_file" ] && grep -qE "^.*\s+${key}=" "$env_file" ; then
        sed -i "s|^.* ${key}=.*$||" "$env_file"
    fi
}
export -f crf.removeFromRuntimeEnvironment

#############################################################################
function crf.runScript()
{
    local file=${1:?"Input parameter 'file' must be passed to 'function ${FUNCNAME[0]}()'"}
    local tmp_script="/tmp/crfScript.$( basename "$file" )"

    term.log "..executing ${file}\n" 'info'

cat << EOF > "$tmp_script"
#!/bin/bash

# Use the Unofficial Bash Strict Mode
set -o errexit
set -o nounset
set -o pipefail
IFS=\$'\n\t'

function sourcingMessage()
{
    local -r src=\$1
    local -r name="\$(basename "\$src")"
    local \dir="\$(dirname "\$src")"
    [ \$(( __env_count++ )) -eq 0 ] && printf "    sourcing (%s):  " "$(term.log 'CRF' 'magenta')" 
    printf "\x1b[%dm%s\x1b[0m " 35 "\$name"
}


# load the associative array defitions
declare -i __env_count=0
declare -ra _files=( \$(lib.getFiles "\$(crf.ENV)") )
for _src in "$(printf "%s\n" "\${_files[@]}" | sort)"; do
    sourcingMessage "\${_src}" 
    source "\$_src"
done
[ \$__env_count -gt 0 ] && echo ''

cd "$WORKDIR"
source "$file"
EOF

    chmod 755 "$file"
    chmod 755 "$tmp_script"
    local -i status
    ( command "$tmp_script" ) && status=$? || status=$?
    if [ $status -ne 0 ]; then
        term.log "-------------------------------------------------------------\n"
        cat "$file"
        term.log "\n-------------------------------------------------------------\n"
        term.log ">>>>> issue while executing $( basename "$file" ) <<<<<\n" 'warn'
    fi
    rm  "$tmp_script"
    return $status
}
export -f crf.runScript

#############################################################################
function crf.runtimeProperty()
{
    local key="${1:?"Input parameter 'key' must be passed to 'function ${FUNCNAME[0]}()'"}"

    local env_file="$(crf.RT_ENVIRON)"
    [ -e "$env_file" ] || return

    lib.getProperty "$(crf.RT_ENVIRON_PREFIX)${key}" "$env_file"
}
export -f crf.runtimeProperty

#############################################################################
function crf.updateRuntimeEnvironment()
{
    local -a in_array=( "$@" )
    
    local -r env_file="$( crf.RT_ENVIRON )"
    [ -e "$env_file" ] || return
    
    
    for line in "${in_array[@]}"; do
        local key="${line%%=*}"
        if grep -qE "^.*\s+${key}=" "$env_file" ; then
            sed -i "s|^.* ${key}=.*$|$(crf.RT_ENVIRON_PREFIX)$line|" "$env_file"
        else
            echo "$(crf.RT_ENVIRON_PREFIX)$line" >> "$env_file"
        fi
    done
}
export -f crf.updateRuntimeEnvironment

