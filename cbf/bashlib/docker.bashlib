#!/bin/bash

#----------------------------------------------------------------------------------------------
#
#   docker.bashlib; basic functions to get info about docker containers
#

#----------------------------------------------------------------------------------------------
function docker.baseImage()
{
    local -r ref="${1:?}"

    local base="${ref%:*}"
    local registry="$(registry.SERVER)"
    [[ "$base" =~ "$registry"* ]] || base="${registry}$base"
    echo "$base"
}
export -f docker.baseImage

#----------------------------------------------------------------------------------------------
function docker.clean()
{
    local -a collection
    local -i blocksUsedBefore="$(df /var/lib/docker/volumes | awk '{if (NR==2) {print $3}}')"

    # remove all containers which are stopped along with their associated volumes
    collection=()
    collection+=( $(docker ps --all --quiet --filter "status=dead" --format "{{.Names}}") )
    collection+=( $(docker ps --all --quiet --filter "status=exited" --format "{{.Names}}") )
    if [ "${#collection[*]}" -gt 0 ]; then
        printf "Deleting %d exited containers\n" "${#collection[*]}"
        docker rm --volumes "${collection[@]}"
    fi


    local fingerprint image
    # remove any 'dangling' images  (those with <none> in name)
    collection=( $(docker images --quiet --filter "dangling=true") )

    # locate all images tagged as ':tmp'
    for image in $(docker image ls --format '{{.Repository}}:{{.Tag}}' | grep -s ':tmp' ||:); do
        collection+=( $image )
    done

    # locate all images tagged with a computed fingerprint
    for image in $(docker image ls --format '{{.Repository}}:{{.Tag}}' | grep -v '<none>' ||:); do
        fingerprint=$(docker inspect "$image" | jq -r '.[].Config.Labels."container.fingerprint"?') ||:
        [ -z "${fingerprint:-}" ] && continue
        [ "$fingerprint" != "$(docker.tag "$image")" ] && continue
        collection+=( $image )
    done

    # locate all images with '<none>' as Repository
    for image in $((docker images | grep -s '<none>'  ||:) | awk '{if($1 == "<none>"){print $3}}'); do
        fingerprint=$(docker inspect "$image" | jq -r '.[].Config.Labels."container.fingerprint"?') ||:
        [ -z "${fingerprint:-}" ] && continue
        collection+=( $image )
    done

    if [ "${#collection[*]}" -gt 0 ]; then
        mapfile -t collection < <(printf '%s\n' ${collection[@]} | sort -u)   # remove duplicates

        # Allow any images associated with running containers
        local -r processes="$(for i in $(docker ps --all --format '{{.Image}}'); do docker inspect $i 2>/dev/null | jq -r '[.[].Id[7:19]]|unique[]' ||: ;done)"
        local -i idx=${#collection[*]}
        while [ $(( idx-- )) -gt 0 ]; do
            image=${collection[$idx]}
            [[ $(grep -c "$image" <<< "${processes}") -gt 0 ]] && unset collection[$idx]
        done

        # Finally, remove all the images we found
        if [ "${#collection[*]}" -gt 0 ]; then
            printf "Deleting %d dangling/temporary images\n" "${#collection[*]}"
            docker rmi ${collection[@]} ||:
        fi
    fi


    # get list of volumes associated with running containers
    collection=()
    for volume in $(docker ps --all --quiet); do
        collection+=( $(docker inspect "$volume" | jq -r '.[].Mounts[].Name | select(.)' | sort -u) )
    done
    [ "${#collection[*]}" -gt 0 ] && printf "Detected %d mounts associated with running containers\n" "${#collection[*]}"


    # remove directories associated with unused volumes
    if [ "${#collection[*]}" -gt 0 ]; then
        local -i deletions=0
        local volumes="$( printf "%s\n" "${collection[@]}" )"
        for dir in $(sudo find '/var/lib/docker/volumes/' -mindepth 1 -maxdepth 1 -type d); do
            (grep "$dir" <<< "$volumes") && continue
            sudo rm -rf "$dir"
            (( deletions++ )) ||:
        done
        [ $deletions -gt 0 ] && printf "Deleted %d directories associated with volumes no longer in use\n" $deletions
    fi


    # show results
    (
        local -i blocksUsedAfter="$(df /var/lib/docker/volumes | awk '{if (NR==2) {print $3}}')"
        local -i recovered=$(( blocksUsedBefore - blocksUsedAfter ))
        [ $recovered -le 0 ] || printf "Recovered %d kb\n" $recovered
        echo
    ) >&2
}
export -f docker.clean

#----------------------------------------------------------------------------------------------
function docker.isRunning()
{
    if [ -S /run/docker.sock ]; then
        curl --silent --unix-socket /run/docker.sock GET http://127.0.0.1/ping &> /dev/null && return 0
    fi
    return 1
}
export -f docker.isRunning

#----------------------------------------------------------------------------------------------
function docker.networks()
{
    local -a networks=( $( docker network ls | grep 'default' | awk "{ print \$1 }" ) )
    docker network inspect "${networks[@]}" \
    | jq -r ".[].Containers|.[]|[.IPv4Address + \" : \" + .Name]|.[]" \
    | sort -t "." -k 4g
}
export -f docker.networks

#----------------------------------------------------------------------------------------------
function docker.pushRetained()
{
    local -ri isRetainedImage="${1:?}"
    shift
    local -ra images=( "$@" )
    [ ${#images[*]} -eq 0 ] && return 1

    local imageList=$(docker images --format '{{.Repository}}:{{.Tag}}')

    local image
    local -a allImages=()
    for image in "${images[@]}"; do
        grep -q "$image" <<< "$imageList" || continue
        allImages+=( "$image" )
        [ "${isRetainedImage:-0}" -gt 0 ] || continue
        local fp="$(docker inspect "$image" | jq -r '.[].Config.Labels."container.fingerprint"?')"
        if [ "${fp:-}" ]; then
            allImages+=( "${image%:*}:${fp}" )
            docker tag "$image" "${image%:*}:${fp}"  > /dev/null 2>&1 ||: # ignore errors
        fi
    done
    [ "${#allImages[*]}" -gt 0 ] || trap.die 'no valid images found'
    mapfile -t allImages < <(printf '%s\n' "${allImages[@]}" | uniq)

    local attempt
    local -i wasPushed
    for image in "${allImages[@]}"; do
        wasPushed=0
        for attempt in {0..2}; do
            term.log "    Pushing ${image}"'\n' 'lt_blue'
            docker push "$image" && wasPushed=1 && break
            echo 'retrying...'
        done
        [ "$wasPushed" -eq 0 ] && trap.die "Failed to push $image"
    done

    for image in "${allImages[@]}"; do
        local -i wasTagged=0
        for inp in "${images[@]}"; do
            [ "$inp" = "$image" ] && wasTagged=1 && break
        done
        [ "$wasTagged" -eq 1 ] || docker rmi "$image"
    done
}
export -f docker.pushRetained

#----------------------------------------------------------------------------------------------
function docker.repo()
{
    local -r ref="${1:?}"

    local repo="${ref%:*}"
    local registry="$(registry.SERVER)"
    [[ "$repo" =~ "$registry"* ]] && repo="${repo#${registry}}"
    echo "$repo"
}
export -f docker.repo

#----------------------------------------------------------------------------------------------
function docker.services()
{
    local -r dc_yaml="${1:?'no docker-compose.yml specified'}"

    lib.yamlToJson "$dc_yaml" | jq -r '.services|keys[]?'
}
export -f docker.services

#----------------------------------------------------------------------------------------------
function docker.showProcessReport()
{
    local -r opts=${1:-}

    local fmt='table {{.Names}}\t{{.ID}}\t{{.Size}}\t{{.Status}}\t{{.RunningFor}}'
    [ "$opts" ] || fmt="$fmt"'\t{{.Ports}}'

    # show process report
    echo
    mapfile -t containers < <(docker ps --format "$fmt")
    echo -e "\e[97m${containers[0]}\e[0m"
    unset containers[0]
    printf '%s\n' "${containers[@]}" | sort
}
export -f docker.showProcessReport

#----------------------------------------------------------------------------------------------
function docker.tag()
{
    local -r ref="${1:?}"
    echo "${ref##*:}"
}
export -f docker.tag

#----------------------------------------------------------------------------------------------
